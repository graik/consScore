#/usr/bin/env python3

"""
    Intakes a protein sequence in fasta format, and returns the conservation 
    score of the residues in the protein
"""

#import os
from Bio import SeqIO as sq
import json
import requests
from Bio.Align.Applications import ClustalwCommandline as cline
from Bio import AlignIO as al
from Bio.Align import AlignInfo as ai
from Bio import Alphabet

base_url = 'http://www.orthodb.org/'
headers = {'Content-Type': 'application/json'}
    
def get_orthoids(filepath):
    """
    Take a fasta file and return a list of OrthoDB cluster IDs. Note that this 
    is only useful for animal proteins.
    
    Args:
        filepath (string): The absolute path leading to the fasta file of interest.
    Returns: 
        A list of OrthoDB ortholog IDs which can then be used to retrieve a list 
        of orthologs in a fasta file.
    """
    
    with open(filepath) as workfile:
        prerec = list(sq.parse(workfile, "fasta"))
    rec= prerec[0]
    st = rec.seq
    url = '{0}/blast?seq={1}&level=33208&limit=100'.format(base_url, st)
    # level in this case refers to the taxid from ncbi database- currently set 
    # at metazoa
    # limit 100 means that at most 100 OrthoDB IDs will be returned- not general
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        response = json.loads(response.content.decode('utf-8'))
        return response['data']

    elif response.status_code == 500:
        print ('[!][{0}] Server Error'.format(response.status_code))
        return None
    elif response.status_code == 404:
        print('[!] [{0}] URL not found: [{1}]'.format(response.status_code,url))
        return None  
    elif response.status_code == 401:
        print('[!] [{0}] Authentication Failed'.format(response.status_code))
        return None
    elif response.status_code == 400:
        print('[!] [{0}] Bad Request'.format(response.status_code))
        return None
    elif response.status_code == 300:
        print('[!] [{0}] Unexpected Redirect'.format(response.status_code))
        return None
    else:
        print('[?] Unexpected Error: [HTTP {0}]: Content: {1}'.format(response.status_code, response.content))
    return None
    
def get_orthologs(IDlist= [], index=0, filename= 'default'):
    """
    Takes a list of OrthoDB ID strings, and returns a file containing sequences in fasta
    format
    
    Args: 
        IDlist (list): A list of strings, where each string is a OrthoDB cluster id
        index(int): Specifies the index of the desired OrthoDB id, to retrieve the 
            orthologs associated with that ID. Defaults to the first string in the
            because the API returns a list with the best matching cluster first
        filename (str): The name that will be given to the fasta file that is 
            written.
        
    Returns: A fasta file containing the relevant orthologs in the same directory
        as the program
    """
    ID = IDlist[index]
    url = '{0}/fasta?id={1}'.format(base_url, ID)
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        fast= response.content.decode('utf-8')
        with open(filename+'.fasta', 'w') as workfile:
            workfile.write(fast)
    else:
        return response.status_code
    
def get_alignment(fastafile = "", path = r"/weyr/software/clustalw2/v2.1-bin.app/bin/clustalw2"):
    """
    Takes a fasta file with multiple sequences as input, and outputs an alignment file generated by 
    Clustalw2
    
    Args: 
        fastafile (str): The name of the fasta file that is being aligned. Note
            that the fasta file must be in the same directory as the script.
    
    Returns: A .aln and .dnd file, both showing the alignments of the input
        sequences
    """
    clus_cline = cline(path,  infile = fastafile)
    #assert os.path.isfile(clustalw_exe), "Clustal W executable missing"
    stdout, stderr = clus_cline()  
    print(clus_cline)

#def get_information(filename = "", fileformat= "clustal"):
#    """
#    """
#    prealign = list(al.parse(filename, fileformat))
#    align = prealign[0]
#    summary = ai.SummaryInfo(align)
#    return summary.information_content()
#    #info_content = summary.information_content()
#    #return info_content
    
    
    
    
